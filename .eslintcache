[{"C:\\Users\\Admin\\work\\upwork\\react-login-register-page\\src\\index.js":"1","C:\\Users\\Admin\\work\\upwork\\react-login-register-page\\src\\App.js":"2","C:\\Users\\Admin\\work\\upwork\\react-login-register-page\\src\\firebase.js":"3","C:\\Users\\Admin\\work\\upwork\\react-login-register-page\\src\\UserContext.js":"4","C:\\Users\\Admin\\work\\upwork\\react-login-register-page\\src\\pages\\LandingPage.js":"5","C:\\Users\\Admin\\work\\upwork\\react-login-register-page\\src\\pages\\HomePage\\index.jsx":"6","C:\\Users\\Admin\\work\\upwork\\react-login-register-page\\src\\pages\\SignIn\\index.jsx":"7","C:\\Users\\Admin\\work\\upwork\\react-login-register-page\\src\\pages\\HomePage\\handleOp.ts":"8"},{"size":151,"mtime":1681550187959,"results":"9","hashOfConfig":"10"},{"size":1895,"mtime":1682004225895,"results":"11","hashOfConfig":"10"},{"size":1035,"mtime":1681656342411,"results":"12","hashOfConfig":"10"},{"size":91,"mtime":1681895053445,"results":"13","hashOfConfig":"10"},{"size":753,"mtime":1681895053451,"results":"14","hashOfConfig":"10"},{"size":18639,"mtime":1682005453762,"results":"15","hashOfConfig":"10"},{"size":5354,"mtime":1681984653646,"results":"16","hashOfConfig":"10"},{"size":6321,"mtime":1682001342772,"results":"17","hashOfConfig":"10"},{"filePath":"18","messages":"19","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"20"},"1tmwfqi",{"filePath":"21","messages":"22","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"20"},{"filePath":"23","messages":"24","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"20"},{"filePath":"25","messages":"26","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"20"},{"filePath":"27","messages":"28","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"20"},{"filePath":"29","messages":"30","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"31","messages":"32","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"33","usedDeprecatedRules":"20"},{"filePath":"34","messages":"35","errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"36","usedDeprecatedRules":"37"},"C:\\Users\\Admin\\work\\upwork\\react-login-register-page\\src\\index.js",[],["38","39"],"C:\\Users\\Admin\\work\\upwork\\react-login-register-page\\src\\App.js",[],"C:\\Users\\Admin\\work\\upwork\\react-login-register-page\\src\\firebase.js",[],"C:\\Users\\Admin\\work\\upwork\\react-login-register-page\\src\\UserContext.js",[],"C:\\Users\\Admin\\work\\upwork\\react-login-register-page\\src\\pages\\LandingPage.js",[],"C:\\Users\\Admin\\work\\upwork\\react-login-register-page\\src\\pages\\HomePage\\index.jsx",["40"],"C:\\Users\\Admin\\work\\upwork\\react-login-register-page\\src\\pages\\SignIn\\index.jsx",["41"],"import React, { useState, useContext } from \"react\";\r\nimport { Link, useHistory } from \"react-router-dom\";\r\nimport { Box, TextField, Button } from \"@mui/material\";\r\nimport bcryptjs from \"bcryptjs\";\r\n\r\nimport { UserContext } from \"../../UserContext\";\r\nconst crypto = require('crypto');\r\nconst SignIn = () => {\r\n    const [username, setUsername] = useState(\"\");\r\n    const [password, setPassword] = useState(\"\");\r\n    const [usernameError, setUsernameError] = useState(null);\r\n    const [passwordError, setPasswordError] = useState(null);\r\n\r\n    const userData = useContext(UserContext);\r\n    const history = useHistory();\r\n\r\n    const handleUsernameChange = (e) => {\r\n        setUsername(e.target.value);\r\n        setUsernameError(null);\r\n    };\r\n\r\n    const handlePasswordChange = (e) => {\r\n        setPassword(e.target.value);\r\n        setPasswordError(null);\r\n    };\r\n\r\n    const handleCheckExistsAccount = () => {\r\n        return userData.find((user) => user.id === username);\r\n    };\r\n\r\n    const verifyPassword = async (password, hash) => {\r\n        try {\r\n            // Compare the provided password with the stored hash\r\n            const isMatch = await bcryptjs.compare(password, hash);\r\n            return isMatch;\r\n        } catch (error) {\r\n            console.error(\"Error verifying password:\", error);\r\n            throw error;\r\n        }\r\n    };\r\n    const deriveKey = async (passphrase) => {\r\n        // Generate a random salt\r\n        const salt = \"0x\";\r\n\r\n        // Derive a 32-byte key from the passphrase using PBKDF2\r\n        const key = crypto.pbkdf2Sync(passphrase, salt, 100000, 32, 'sha256');\r\n\r\n        return key.toString('hex')\r\n    }\r\n    // Encrypt data using AES-CBC with a given key\r\n    function encryptDataWithKey(key, data) {\r\n        // Generate a random IV (Initialization Vector)\r\n        const iv = crypto.randomBytes(16);\r\n\r\n        // Create a cipher using AES-CBC algorithm\r\n        const cipher = crypto.createCipheriv('aes-256-cbc', key, iv);\r\n\r\n        // Encrypt the data\r\n        const encryptedBuffer = Buffer.concat([cipher.update(data, 'utf8'), cipher.final()]);\r\n\r\n        // Combine the IV and ciphertext into a single Buffer\r\n        const encryptedData = Buffer.concat([iv, encryptedBuffer]);\r\n\r\n        // Convert the encrypted data to hexadecimal string\r\n        const encryptedHexString = encryptedData.toString('hex');\r\n\r\n        return encryptedHexString;\r\n    }\r\n\r\n    const handleSubmit = async () => {\r\n        // Validate input fields\r\n        if (!username) {\r\n            setUsernameError(\"Please enter a username\");\r\n            return;\r\n        }\r\n        if (!password) {\r\n            setPasswordError(\"Please enter a password\");\r\n            return;\r\n        }\r\n        const matchingUser = await handleCheckExistsAccount();\r\n        if (!matchingUser) {\r\n            setUsernameError(\"Account does not exist\");\r\n            return;\r\n        }\r\n\r\n        const isMatch = await verifyPassword(\r\n            password,\r\n            matchingUser.hashedPassword\r\n        );\r\n        if (!isMatch) {\r\n            setPasswordError(\"Password do not match\");\r\n            return;\r\n        }\r\n\r\n        localStorage.setItem(\"account\", JSON.stringify(matchingUser));\r\n        const encryptedPasswordStr = await deriveKey(password)\r\n        // const encryptedPassword = Buffer.from(encryptedPasswordStr, 'hex');\r\n        localStorage.setItem(\"encryptedPassword\", encryptedPasswordStr)\r\n        history.push(\"/home\");\r\n    };\r\n\r\n    return (\r\n        <div className=\"signin text-center m-5-auto\">\r\n            <h2>Sign in to us</h2>\r\n            <Box\r\n                sx={{\r\n                    display: \"flex\",\r\n                    flexDirection: \"column\",\r\n                    alignItems: \"left\",\r\n                    width: \"30ch\",\r\n                    margin: \"0 auto\",\r\n                    textAlign: \"left\",\r\n                }}>\r\n                <p className=\"signin-form-label\">Username</p>\r\n                <TextField\r\n                    autoFocus\r\n                    autoComplete=\"off\"\r\n                    value={username}\r\n                    onChange={handleUsernameChange}\r\n                    error={!!usernameError}\r\n                    helperText={usernameError}\r\n                />\r\n                <p className=\"signin-form-label\">Password</p>\r\n                <TextField\r\n                    autoComplete=\"off\"\r\n                    value={password}\r\n                    type=\"password\"\r\n                    onChange={handlePasswordChange}\r\n                    error={!!passwordError}\r\n                    helperText={passwordError}\r\n                />\r\n            </Box>\r\n\r\n            <Box\r\n                sx={{\r\n                    display: \"flex\",\r\n                    flexDirection: \"column\",\r\n                    alignItems: \"center\",\r\n                    marginTop: \"30px\",\r\n                    gap: \"10px\",\r\n                    \"& .MuiButton-root\": {\r\n                        width: \"25ch\",\r\n                    },\r\n                }}>\r\n                <Button variant=\"contained\" onClick={handleSubmit}>\r\n                    Sign in\r\n                </Button>\r\n                <Button variant=\"outlined\">\r\n                    <Link to=\"/\">BACK TO HOMEPAGE</Link>\r\n                </Button>\r\n            </Box>\r\n        </div>\r\n    );\r\n};\r\n\r\nexport default SignIn;\r\n","C:\\Users\\Admin\\work\\upwork\\react-login-register-page\\src\\pages\\HomePage\\handleOp.ts",["42","43","44","45","46"],"import { ethers } from \"ethers\";\r\nimport { UserOperation } from \"./UserOperation\";\r\nimport {\r\n  defaultAbiCoder,\r\n  hexDataSlice,\r\n  keccak256,\r\n  hexConcat,\r\n} from \"ethers/lib/utils\";\r\nimport AccountAbi from \"../../ABI/Account.json\";\r\nimport EntrypointAbi from \"../../ABI/EntryPoint.json\";\r\nimport ERC721ABI from \"../../ABI/ERC721.json\";\r\nimport ERC1155ABI from \"../../ABI/ERC1155.json\";\r\nconst provider = new ethers.providers.JsonRpcProvider(\r\n  \"https://data-seed-prebsc-1-s1.binance.org:8545\"\r\n);\r\nconst entryPoint = new ethers.Contract(\r\n  \"0x91Bf50D45d66BCebeC525DbD54FBF6257fFe759E\",\r\n  EntrypointAbi,\r\n  provider\r\n);\r\n// encode\r\nfunction encode(\r\n  typevalues: Array<{ type: string; val: any }>,\r\n  forSignature: boolean\r\n): string {\r\n  const types = typevalues.map((typevalue) =>\r\n    typevalue.type === \"bytes\" && forSignature ? \"bytes32\" : typevalue.type\r\n  );\r\n  const values = typevalues.map((typevalue) =>\r\n    typevalue.type === \"bytes\" && forSignature\r\n      ? keccak256(typevalue.val)\r\n      : typevalue.val\r\n  );\r\n  return defaultAbiCoder.encode(types, values);\r\n}\r\n\r\n// helper to pack UserOperation\r\nexport function packUserOp(op: UserOperation, forSignature = true): string {\r\n  if (forSignature) {\r\n    // lighter signature scheme (must match UserOperation#pack): do encode a zero-length signature, but strip afterwards the appended zero-length value\r\n    const userOpType = {\r\n      components: [\r\n        { type: \"address\", name: \"sender\" },\r\n        { type: \"uint256\", name: \"nonce\" },\r\n        { type: \"bytes\", name: \"initCode\" },\r\n        { type: \"bytes\", name: \"callData\" },\r\n        { type: \"uint256\", name: \"callGasLimit\" },\r\n        { type: \"uint256\", name: \"verificationGasLimit\" },\r\n        { type: \"uint256\", name: \"preVerificationGas\" },\r\n        { type: \"uint256\", name: \"maxFeePerGas\" },\r\n        { type: \"uint256\", name: \"maxPriorityFeePerGas\" },\r\n        { type: \"bytes\", name: \"paymasterAndData\" },\r\n        { type: \"bytes\", name: \"signature\" },\r\n      ],\r\n      name: \"userOp\",\r\n      type: \"tuple\",\r\n    };\r\n    let encoded = defaultAbiCoder.encode(\r\n      [userOpType as any],\r\n      [{ ...op, signature: \"0x\" }]\r\n    );\r\n    // remove leading word (total length) and trailing word (zero-length signature)\r\n    encoded = \"0x\" + encoded.slice(66, encoded.length - 64);\r\n    return encoded;\r\n  }\r\n  const typevalues = [\r\n    { type: \"address\", val: op.sender },\r\n    { type: \"uint256\", val: op.nonce },\r\n    { type: \"bytes\", val: op.initCode },\r\n    { type: \"bytes\", val: op.callData },\r\n    { type: \"uint256\", val: op.callGasLimit },\r\n    { type: \"uint256\", val: op.verificationGasLimit },\r\n    { type: \"uint256\", val: op.preVerificationGas },\r\n    { type: \"uint256\", val: op.maxFeePerGas },\r\n    { type: \"uint256\", val: op.maxPriorityFeePerGas },\r\n    { type: \"bytes\", val: op.paymasterAndData },\r\n  ];\r\n  if (!forSignature) {\r\n    // for the purpose of calculating gas cost, also hash signature\r\n    typevalues.push({ type: \"bytes\", val: op.signature });\r\n  }\r\n  return encode(typevalues, forSignature);\r\n}\r\n\r\nexport async function fillUserOp(\r\n  sender: string,\r\n  callData: string\r\n): Promise<UserOperation> {\r\n  const accountIns = new ethers.Contract(sender, AccountAbi, provider);\r\n  let nonce = (await accountIns.getNonce()).toNumber();\r\n  let op: UserOperation = {\r\n    sender,\r\n    callData,\r\n    nonce,\r\n    initCode: \"0x\",\r\n    callGasLimit: 30000,\r\n    verificationGasLimit: 300000,\r\n    preVerificationGas: 0,\r\n    maxFeePerGas: \"10000000000\",\r\n    maxPriorityFeePerGas: \"10000000000\",\r\n    signature: \"0x\",\r\n    paymasterAndData: \"0x\",\r\n  };\r\n  try {\r\n    const gasEtimated = await provider.estimateGas({\r\n      from: entryPoint?.address,\r\n      to: op.sender,\r\n      data: op.callData,\r\n    });\r\n    op.callGasLimit = gasEtimated.toNumber(); // .add(55000)\r\n  } catch {\r\n    op.callGasLimit = 1000000;\r\n  }\r\n  return op;\r\n}\r\n//helper to sign message\r\nexport async function signUserOp(\r\n  op: UserOperation,\r\n  owner?: ethers.Wallet\r\n): Promise<UserOperation> {\r\n  let ownerSig: any;\r\n  console.log(\"op: \", op);\r\n  const structString = ethers.utils.defaultAbiCoder.encode(\r\n    // Replace with the types of your struct fields\r\n    [\r\n      \"address\",\r\n      \"uint256\",\r\n      \"bytes\",\r\n      \"bytes\",\r\n      \"uint256\",\r\n      \"uint256\",\r\n      \"uint256\",\r\n      \"uint256\",\r\n      \"uint256\",\r\n      \"bytes\",\r\n      \"bytes\",\r\n    ],\r\n    // Replace with the values of your struct fields\r\n    [\r\n      op.sender,\r\n      op.nonce,\r\n      op.initCode,\r\n      op.callData,\r\n      op.callGasLimit,\r\n      op.verificationGasLimit,\r\n      op.preVerificationGas,\r\n      op.maxFeePerGas,\r\n      op.maxPriorityFeePerGas,\r\n      op.paymasterAndData,\r\n      op.signature,\r\n    ]\r\n  );\r\n  console.log(\"struct str\", structString);\r\n  const message = await entryPoint.getUserOpHash(op);\r\n\r\n  console.log(\"mess: \", message);\r\n  if (owner) {\r\n    ownerSig = await signMessage(message, owner);\r\n  }\r\n\r\n  return {\r\n    ...op,\r\n    signature: ownerSig,\r\n  };\r\n}\r\nexport async function submitOp(sender: ethers.Wallet, op: UserOperation) {\r\n  try {\r\n    console.log([op]);\r\n    const tx = await entryPoint\r\n      .connect(sender.connect(provider))\r\n      .handleOps([op], \"0xD03827055dA3e847abD2D59b9ca74A8897A1fABb\", {\r\n        gasLimit: 500000,\r\n      });\r\n    const receipt = await tx.wait();\r\n    return receipt;\r\n  } catch (error) {\r\n    console.error(\"err:\", error);\r\n  }\r\n}\r\n\r\nexport async function signMessage(\r\n  message: string,\r\n  signer: ethers.Wallet\r\n): Promise<string> {\r\n  const sig = await signer.signMessage(ethers.utils.arrayify(message));\r\n\r\n  let v = parseInt(sig.substring(130, 132), 16);\r\n\r\n  if (v < 27) v += 27;\r\n\r\n  const normalizedSig = `${sig.substring(0, 130)}${v.toString(16)}`;\r\n\r\n  return normalizedSig;\r\n}\r\n//helper to encode Function (helper low lv call) -> callData\r\nexport function encodeFunction(\r\n  type: string,\r\n  func: string,\r\n  params: any[]\r\n): string {\r\n  let abi: string = \"\";\r\n  if (type == \"erc721\") {\r\n    abi = JSON.stringify(ERC721ABI);\r\n  } else if (type == \"erc1155\") {\r\n    abi = JSON.stringify(ERC1155ABI);\r\n  } else if (type == \"account\") {\r\n    abi = JSON.stringify(AccountAbi);\r\n  }\r\n  const accountInterface = new ethers.utils.Interface(abi);\r\n  const args = params;\r\n  return accountInterface.encodeFunctionData(func, args);\r\n}\r\n",["47","48"],{"ruleId":"49","replacedBy":"50"},{"ruleId":"51","replacedBy":"52"},{"ruleId":"53","severity":1,"message":"54","line":335,"column":8,"nodeType":"55","endLine":335,"endColumn":27,"suggestions":"56"},{"ruleId":"57","severity":1,"message":"58","line":51,"column":14,"nodeType":"59","messageId":"60","endLine":51,"endColumn":32},{"ruleId":"61","severity":1,"message":"62","line":5,"column":3,"nodeType":"59","messageId":"60","endLine":5,"endColumn":15},{"ruleId":"61","severity":1,"message":"63","line":7,"column":3,"nodeType":"59","messageId":"60","endLine":7,"endColumn":12},{"ruleId":"64","severity":1,"message":"65","line":202,"column":12,"nodeType":"66","messageId":"67","endLine":202,"endColumn":14},{"ruleId":"64","severity":1,"message":"65","line":204,"column":19,"nodeType":"66","messageId":"67","endLine":204,"endColumn":21},{"ruleId":"64","severity":1,"message":"65","line":206,"column":19,"nodeType":"66","messageId":"67","endLine":206,"endColumn":21},{"ruleId":"49","replacedBy":"50"},{"ruleId":"51","replacedBy":"52"},"no-native-reassign",["68"],"no-negated-in-lhs",["69"],"react-hooks/exhaustive-deps","React Hook useEffect has a missing dependency: 'getBalance'. Either include it or remove the dependency array.","ArrayExpression",["70"],"no-unused-vars","'encryptDataWithKey' is defined but never used.","Identifier","unusedVar","@typescript-eslint/no-unused-vars","'hexDataSlice' is defined but never used.","'hexConcat' is defined but never used.","eqeqeq","Expected '===' and instead saw '=='.","BinaryExpression","unexpected","no-global-assign","no-unsafe-negation",{"desc":"71","fix":"72"},"Update the dependencies array to be: [address, getBalance, openNoti]",{"range":"73","text":"74"},[11603,11622],"[address, getBalance, openNoti]"]